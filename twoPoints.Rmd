---
title: "Pictures of Stress"
author: 
- Jan de Leeuw - University of California Los Angeles
date: '`r paste("Started June 29 2016, Version of",format(Sys.Date(),"%B %d, %Y"))`'
output:
  bookdown::pdf_document2:
    latex_engine: lualatex 
    includes:
      in_header: preamble.tex
    keep_tex: yes
    toc: true
    toc_depth: 3
    number_sections: yes
  bookdown::html_document2:
    keep_md: yes
    css: preamble.css
    toc: true
    toc_depth: 3
    number_sections: yes
graphics: yes
mainfont: Times New Roman
fontsize: 12pt
bibliography: ["mypubs.bib","total.bib"]
abstract: A low-dimensional multidimensional scaling example is used to illustrate properties of the stress loss function and of different iteration methods.
---
```{r loadpackages, echo = FALSE}
suppressPackageStartupMessages(library (captioner, quietly = TRUE))
```

```{r load code, echo = FALSE}
#dyn.load("foo.so")
source("janUtil.R")
```

```{r packages, echo = FALSE}
figure_nums <- captioner(prefix = "Figure")
table_nums <- captioner(prefix = "Table")
lemma_nums <- captioner(prefix = "Lemma")
theorem_nums <- captioner(prefix = "Theorem")
corollary_nums <- captioner(prefix = "Corollary")
figure_nums(name = "global_perspective", caption = "Global Perspective", display = FALSE)
figure_nums(name = "global_contour", caption = "Global Contour", display = FALSE)
figure_nums(name = "configuration_first_minimum", caption = "Configuration First Minimum", display = FALSE)
figure_nums(name = "contour_first_minimum", caption = "Contour Plot First Minimum", display = FALSE)
figure_nums(name = "configuration_second_minimum", caption = "Configuration Second Minimum", display = FALSE)
figure_nums(name = "contour_second_minimum", caption = "Contour Plot Second Minimum", display = FALSE)
figure_nums(name = "configuration_third_minimum", caption = "Configuration Third Minimum", display = FALSE)
figure_nums(name = "contour_third_minimum", caption = "Contour Plot Third Minimum", display = FALSE)
figure_nums(name = "configuration_first_saddlepoint", caption = "Configuration First Saddlepoint", display = FALSE)
figure_nums(name = "contour_first_saddlepoint", caption = "Contour Plot First Saddlepoint", display = FALSE)
figure_nums(name = "configuration_second_saddlepoint", caption = "Configuration Second Saddlepoint", display = FALSE)
figure_nums(name = "contour_second_saddlepoint", caption = "Contour Plot Second Saddlepoint", display = FALSE)
figure_nums(name = "histogram_smacof", caption = "Histogram Number of Smacof Iterations", display = FALSE)
figure_nums(name = "path_smacof", caption = "Path Endpoints of Smacof Iterations", display = FALSE)
figure_nums(name = "histogram_newton", caption = "Histogram Number of Newton Iterations", display = FALSE)
figure_nums(name = "path_newton", caption = "Path Endpoints of Newton Iterations", display = FALSE)
figure_nums(name = "rho_contour", caption = "Contour Plot for Rho", display = FALSE)
figure_nums(name = "rho_nonlinear_plot", caption = "One-dimensional Rho", display = FALSE)
lemma_nums(name = "linear", caption = "[On the Line]", display = FALSE)
lemma_nums(name = "nonlinear", caption = "[On the Circle]", display = FALSE)
```
```{r function_code, echo = FALSE}
source("twoPoints.R")
```
Note: This is a working paper which will be expanded/updated frequently. It is a corrected, expanded, and modernized version of @deleeuw_E_16l. All suggestions for improvement are welcome, and some would be really beneficial. For example, I only use base R graphics, nothing more fancy, because base is all I know. The directory [https://github.com/deleeuw/twoPoints](https://github.com/deleeuw/twoPoints)  has pdf and html versions, the complete Rmd file with all code chunks, the bib files, and the R source code.

# Theory

In *Metric, Euclidean, Least Squares Multidimensional Scaling (MELS-MDS)* we minimize a loss function, called *Kruskal's stress*, which is defined by (@kruskal_64a, @kruskal_64b)
\begin{equation}
\sigma(X):=\frac12\{\jis w_{ij}(\delta_{ij}-d_{ij}(X))^2\}
(\#eq:loss)
\end{equation}
over the $n\times p$ *configurations* $X$. 

We assume configurations to be column-centered. The *weights* $W$ and the *dissimilarities* $\Delta$ are known symmetric, non-negative, and hollow matrices
of numbers. The matrix $D(X)$ in \@ref(eq:loss) has the (Euclidean) *distances* between the $n$ *points* in the configuration $X$.
There are no weights in Kruskal's original definition, but we added them 
because they are extremely useful in MDS (@groenen_vandevelden_16). 

We expand stress to
\begin{equation}
\sigma(X):=\frac12\{1 - 2\ \jis w_{ij}\delta_{ij}d_{ij}(X)+\jis w_{ij}d_{ij}^2(X)\},
(\#eq:lossexpand)
\end{equation}
where we have assumed, without loss of generality, that
\begin{equation}
\jis w_{ij}\delta_{ij}^2=1.
(\#eq:normdelta)
\end{equation}

Define the $e_i$ as unit vectors, with zeroes everywhere, except for element $i$, which is equal to one. Also define $A_{ij}:=(e_i-e_j)(e_i-e_j)'$. Then
\begin{equation}
d_{ij}^2(X)=\mathbf{tr}\ X'A_{ij}X.
(\#eq:bmat)
\end{equation}
Next, define the matrix
\begin{equation}
V:=\jis w_{ij}A_{ij},
(\#eq:vdef)
\end{equation}
and the matrix-valued function
\begin{equation}
B(X):=\jis r_{ij}(X)A_{ij},
(\#eq:bdef)
\end{equation}
where
\begin{equation}
r_{ij}(X)=\begin{cases}w_{ij}\frac{\delta_{ij}}{d_{ij}(X)}&\text{ if }d_{ij}(X)>0,\\
0&\text{ if }d_{ij}(X)=0.\end{cases}
(\#eq:rdef)
\end{equation}
Then
\begin{equation}
\sigma(X)=\frac12\{1-2\text{tr}\ X'B(X)X+\text{tr}\ X'VX\}
(\#eq:lossmat)
\end{equation}
Both $V$ and $B(X)$ for any $X$ are double-centered and positive semi-definite.
Without loss of generality (@deleeuw_C_77) we assume that $V$ has rank $n-1$,
with in its one-dimensional null space all vectors proportional to $e$, the
vector with all elements equal to one.

## Reparametrize

Now reparametrize the MDS problem by writing the configuration $X$ as a linear combination of known column-centered matrices $Y_k$, with $k=1,\cdots,K$. Without loss of generality we assume the $Y_k$ are $V$-orthonormal, i.e. 
\begin{equation}
\text{tr}\ Y_k'VY_l=\begin{cases}1&\text{ if }k=l,\\
0&\text{ if }k\not= l.
\end{cases}
(\#eq:ortho)
\end{equation}


If $X=\sum_{k=1}^K\theta_kY_k$ then,
using the $\theta_k$ as the new coordinates, we find
\begin{equation}
\sigma(\theta):=\frac12\{1-\theta'B(\theta)\theta+\theta'\theta\},
(\#eq:losstheta)
\end{equation}
where $B(\theta)$ has elements
\begin{equation}
b_{kl}(\theta):=\text{tr}\ Y_k'B(X)Y_l.
(\#eq:btheta)
\end{equation}

If $K=p(n-1)$, the dimensionality of the space of all column-centered $n\times p$
matrices, the minimizing $\sigma$ from \@ref(eq:losstheta) over $\theta$ is 
the same problem as minimizing $\sigma$ from \@ref(eq:losstheta) over $X$. If
If $K<p(n-1)$ we are minimizing over a subspace of the column-centered $n\times p$
matrices. 

## Two Points

Stress is a complicated function with potentially a large number of local minima and saddle points. In order to study the behavior of stress we shall
look at configurations of the form $X=\theta_1 Y_1+\theta_2 Y_2$, with $Y_1$ and $Y_2$ known, fixed, column-centered and $V$-orthonormal configurations. This makes stress a function of the two variables $\theta=(\theta_1,\theta_2)$, and we can use standard contour and perspective plots to study the function. This extends earlier work by @deleeuw_R_93c and  @deleeuw_E_16l. 

First some simplications. Define the $2\times 2$ matrices
$$
V_{ij}:=\begin{bmatrix}\mathbf{tr}\ XA_{ij}X'&\mathbf{tr}\ XA_{ij}Y'\\\mathbf{tr}\ YA_{ij}X'&\mathbf{tr}\ YA_{ij}Y'\end{bmatrix},
$$
and define $\gamma$ as the vector with elements $\alpha$ and $\beta$. Now
\begin{equation}
\sigma(\gamma)=1-\sum_{i=1}^n\sum_{j=1}^nw_{ij}\delta_{ij}\sqrt{\gamma'V_{ij}\gamma}+\frac12\gamma'V_{\star\star}\gamma,\label{E:gamma}
\end{equation}
where we have assumed for convenience that
$$
\frac12\sum_{i=1}^n\sum_{j=1}^nw_{ij}\delta_{ij}^2=1,
$$
and where
$$
V_{\star\star}:=\sum_{i=1}^n\sum_{j=1}^n w_{ij}V_{ij}.
$$
Note that if all $w_{ij}$ are one, then
$$
V_{\star\star}=2n\begin{bmatrix}X'X&X'Y\\Y'X&Y'Y\end{bmatrix}.
$$

We now make a change of variables, using the Cholesky decomposition $V_{\star\star}=S'S$, with $S$ upper-triangular.  Define $\theta:=S\gamma$ and $U_{ij}:=(S')^{-1}V_{ij}S^{-1}$. Then
\begin{equation}
\sigma(\theta)=1-\sum_{i=1}^n\sum_{j=1}^nw_{ij}\delta_{ij}\sqrt{\theta'U_{ij}\theta}+\frac12\theta'\theta.\label{E:theta}
\end{equation}
In MDS we usually (@deleeuw_C_77) also define the matrix-valued function
\begin{equation}
B(\theta):=\sum_{i=1}^n\sum_{j=1}^nw_{ij}\frac{\delta_{ij}}{d_{ij}(\theta)}U_{ij},\label{E:bdef}
\end{equation}
with $d_{ij}(\theta):=\sqrt{\theta'U_{ij}\theta}$ and the function $\rho(\theta):=\theta'B(\theta)\theta$. Definition $\eqref{E:bdef}$ can be extended using subgradients if $d_{ij}(\theta)=0$ for some $i,j$ (see @deleeuw_C_77). For our purposes we can define $B(\theta)$ more generally by omitting the terms with
$d_{ij}(\theta)=0$. The definition of $\rho$ allows us to write
\begin{equation}
\sigma(\theta)=1-\rho(\theta)+\frac12\theta'\theta.\label{E:short}
\end{equation}
If $d_{ij}(\theta)>0$ for all $i,j$ such that $w_{ij}\delta_{ij}>0$ then stress is differentiable at $\theta$ and  $\mathcal{D}\sigma(\theta)=\theta-B(\theta)\theta$, so that stationary points are defined as solutions of $\theta=B(\theta)\theta$. The more general definition
is $\theta\in\partial\rho(\theta)$. @deleeuw_A_84f shows that stress is always differentiable at local minima.

At a stationary point $\theta$ is an eigenvector of $B(\theta)$ with eigenvalue equal to one. If this is the largest eigenvalue, then $\theta$ actually gives the global minimum of stress (@deleeuw_groenen_mair_E_16e). Also observe that at a stationary point
$\rho(\theta)=\theta'\theta$, and thus $\eqref{E:short}$ implies $\theta'\theta\leq 2$. All stationary values are within a circle or sphere with radius
$\sqrt{2}$.

The `smacof` algorithm (@deleeuw_C_77, @deleeuw_mair_A_09c) is the iterative algorithm
\begin{equation}
\theta^{(k+1)}=B(\theta^{(k)})\theta^{(k)}.
\end{equation}
Note that the algorithm is self-scaling, in the sense that all points on a ray through the origin have the same update. Thus $B(\lambda\theta)(\lambda\theta)=
B(\theta)\theta$ for all $\lambda\not= 0$.

If stress is differentiable at $\theta$ then $\mathcal{D}^2\sigma(\theta)=I-H(\theta)$,
where
\begin{equation}
H(\theta):=\sum_{i=1}^n\sum_{j=1}^nw_{ij}\frac{\delta_{ij}}{d_{ij}(\theta)}\left\{U_{ij}-\frac{U_{ij}\theta\theta'U_{ij}}{\theta'U_{ij}\theta}\right\}.
\end{equation}
Note that $\mathcal{D}\rho(\theta)=B(\theta)\theta$ and $\mathcal{D}^2\rho(\theta)=H(\theta)$. Also note that $H(\lambda\theta)=|\lambda|^{-1}H(\theta)$,
and thus for any $\theta$ there is a $\lambda(\theta)$ such that $\mathcal{D}^2\sigma(\lambda\theta)$ is positive definite for all $\lambda>\lambda(\theta)$.

The `smacof` algorithm convergences to a solution $\theta$ of the stationary equations, with a linear convergence rate equal to the largest eigenvalue of $H(\theta)$
(see @deleeuw_A_88b). 

Note that $\mathcal{D}^2\sigma(\theta)\theta=\theta$, which means that Newton's method takes the form
\begin{equation}
\theta^{(k+1)}=(I-H(\theta^{(k)})^{-1}B(\theta^{(k)})\theta^{(k)}.\label{E:newton}
\end{equation}
Note that Newton is definitely not self-scaling. Equation $\eqref{E:newton}$ also suggest a natural safeguarded version of Newton's method, using
$I-\eta H$, where $0\leq\eta\leq 1$. For $\eta=0$ this is a `smacof` step, for $\eta=1$ this is a Newton step.

On the line through $\theta$ and the origin the function $\sigma$ is a convex quadratic. Thus at every point, except at the origin, there is at least one direction of descent, and consequently stress has only a single local maximum at $\theta=0$, equal to one. In the differentiable case this is also clear from $\mathcal{D}^2\sigma(\theta)\theta=\theta$, which says that the Hessian has at least one positive eigenvalue.

Because stress is an even function, with $\sigma(\theta)=\sigma(-\theta)$ for all $\theta$,  minima come in pairs.


# First Example

Our first example has $n=4$, all weights equal to one, and all dissimilarities equal. The same example has been analyzed by @deleeuw_A_88b, @deleeuw_R_93c, @trosset_mathar_97. For this example the global minimum in two dimensions has its four points in the corners of a square. That is our $X$, which has stress `r 0.02859548`. Our $Y$ is another stationary point, which has three points in the corners of an equilateral triangle and the fourth point in the center of the triangle. Its stress is `r 0.0669873`. Another way of looking at the two configurations is that  $X$ are four points equally spaced on a circle, and $Y$ are three points equally spaced on a circle with the fourth point in the center of the circle. @deleeuw_A_88b erroneously claims that $Y$ is a non-isolated local minimum of stress, but @trosset_mathar_97 have shown there exists a descent direction at $Y$, and thus $Y$ is actually a saddle point. Of course the stationary points defined by $X$ and $Y$ are far from unique, because we can distribute the four points over the various corners in many ways. 

The example is chosen in such a way that there are non-zero $\alpha$ and $\beta$ such that $d_{12}(\alpha X+\beta Y)=0$. In fact $d_{12}$ is the only distance that can be made zero by a non-trivial linear combination. 

Note that we have used $\sigma$ for three different functions. The first one with argument $Z$ is defined on *configuration space*, the second one with argument $\gamma$ on *coefficient space*, and the third one with argument $\theta$ also on *coefficient space*. This is a slight abuse of notation, rather innocuous, but we have to keep it in mind. 

From lemma `r lemma_nums("linear", display = "n")`we see that $\mathcal{D}\sigma(X)=\mathcal{D}\sigma(Y)=0$ then $\mathcal{D}\sigma(1,0)=\mathcal{D}\sigma(0,1)=0$. Thus stationary points in configuration space are preserved as stationary points in coefficient space, but the reverse implication may not be true. If $\mathcal{D}^2\sigma(X)$ and $\mathcal{D}^2\sigma(Y)$ are positive semi-definite, then so are $\mathcal{D}^2\sigma(1,0)$ and $\mathcal{D}^2\sigma(0,1)$. Thus local minima are preserved. But it is entirely possible that $\mathcal{D}^2\sigma(X)$ and/or $\mathcal{D}^2\sigma(Y)$ are indefinite, and that $\mathcal{D}^2\sigma(1,0)$ and/or $\mathcal{D}^2\sigma(0,1)$ are positive semi-definite. 
Thus saddle points in configuration space can be mapped into local minima in coefficient space. As we will see this actually happens with $Y$, the equilateral triangle with center, in our example.

## Global Pictures

```{r example, echo = FALSE}
delta <- as.matrix (dist (diag (4)))
delta <- delta * sqrt (2 / sum (delta ^ 2))
x <- matrix (c(0,0,1,0,0,1,1,1), 4, 2, byrow = TRUE)
y <- matrix (c(0,0,1,0,.5,.5*sqrt(3)), 3, 2, byrow = TRUE)
y <- rbind(y, colSums(y) / 3)
x <- apply (x, 2, function (z) z - mean (z))
y <- apply (y, 2, function (z) z - mean (z))
d1 <- as.matrix (dist (x))
d2 <- as.matrix (dist (y))
lbd1 <- sum (delta * d1) / sum (d1 ^ 2)
x <- x * lbd1
d1 <- d1 * lbd1
lbd2 <- sum (delta * d2) / sum (d2 ^ 2)
y <- y * lbd2
d2 <- d2 * lbd2
by <- - delta/(d2+diag(4))
diag(by)<--rowSums(by)
z <- matrix (0, 2, 2)
z[, 1] <- x[1, ] - x[2, ]
z[, 2] <- y[1, ] - y[2, ]
gm0<-eigen(crossprod(z))$vectors[,2]
xint<-gm0[1]*x+gm0[2]*y
asum <- 2 * 4 * matrix (c (sum(x ^ 2), sum (x * y), sum (x * y), sum (y ^ 2)), 2, 2)
bsum <- chol (asum)
csum <- solve (bsum)
th0 <- bsum %*% gm0
sth1 <- smacof (1.0406404, 0.8849253, x, y, delta, eps=1e-15,verbose=FALSE)
sth2 <- smacof (1, 0, x, y, delta, eps=1e-15,verbose=FALSE)
sth3 <- smacof (0, 1, x, y, delta, eps=1e-15,verbose=FALSE)
th1 <- csum %*% sth1$theta
xso1 <- th1[1] * x + th1[2] * y
th2 <- csum %*% sth2$theta
xso2 <- th2[1] * x + th2[2] * y
th3 <- csum %*% sth3$theta
xso3 <- th3[1] * x + th3[2] * y
sth4 <- newton(0, 1, x, y, delta, eps=1e-15,verbose = FALSE)
th4 <- csum %*% sth4$theta
xso4 <- th4[1] * x + th4[2] * y
sth5<-newton(1.12383710,0.77620456,x,y,delta,eps=1e-15,verbose=FALSE)
th5 <- csum %*% sth5$theta
xso5 <- th5[1] * x + th5[2] * y
```

We first make a global perspective plot, over the range $(-2.5,+2.5)$.

```{r first_array, echo = FALSE, cache = TRUE}
aa <- bb <- seq (-2.5, 2.5, length = 100)
z <- matrix (0, 100, 100)
for (i in 1:100) for (j in 1:100)
  z[i, j]<- stress (aa[i], bb[j], x, y, delta)
```
<hr>
```{r global_perspective, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
par(pty="s")
persp(aa, bb, z, col = "RED", xlab = "theta_1", ylab = "theta_2", zlab = "stress")
```
<center>
`r figure_nums("global_perspective")`
</center>
<hr>

We see the symmetry, following from the fact that stress is even. We also see the local maximum at the origin, where stress is not differentiable. Also note the ridge, where $d_{12}(\theta)=0$ and where stress is not differentiable either.
The ridge shows nicely that on rays emanating from the origin stress is a convex quadratic. Also, far away from the origin, stress globally behaves very much like a convex quadratic (except for the ridge). Clearly local minima must be found in the valleys surrounding the small mountain at the origin, all within the sphere
with radius $\sqrt{2}$.

Figure `r figure_nums("global_contour", display = "n")` is a countour plot of stress over $(-2,+2)\otimes(-2,+2)$. The red line is $\{\theta\mid d_{12}(\theta) = 0\}$. The blue line has the minimum of the convex quadratic on each of the rays through the origin. Thus all local minima, and in fact all stationary points, are on the blue line. Note that the plot uses $\theta$ to define the coordinate axes, not $\gamma=(\alpha,\beta)$. Thus there are no stationary points at $(0,1)$ and $(1,0)$, but at the corresponding points (`r bsum[,1]`) and (`r bsum[,2]`) in the $\theta$ coordinates (and, of course, at their mirror images).

Besides the single local maximum at the origin, it turns out that in this example there are at least five pairs of stationary points. Or, more precisely, I have not been able to find more than five. Each stationary point $\theta$ has a mirror image $-\theta$. Three of the five are local minima, two are saddle points. Local minima are plotted as blue points, saddle points as red points. 

<hr>
```{r global_contour, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
contour(aa, bb, z, levels = seq(0,.30,length=50))
aa <- seq (-2 * pi,  2 * pi, length = 100)
bb <- sin (aa)
cc <- cos (aa)
xxx <- matrix (0, 100, 2)
for (k in 1:100) {
  z <- c (bb[k], cc[k])
  dd <- matrix (0, 4, 4)
  for (i in 1:4)
    for (j in 1:4) {
      dd[i, j] <- sqrt (sum (uu (i, j, x, y) * outer (z, z)))
    }
  lbd <- sum (dd * delta) / sum (dd ^ 2)
  xxx[k, ] <- lbd * z
}
lines (xxx[ ,1], xxx[, 2], lwd = 2, col = "BLUE")
abline (0, th0[2] /th0[1], col = "RED", lwd = 2)
th <-sth1$theta
points (th[1], th[2], pch = 19, cex = 1.0, col = "BLUE")
th <- -th
points (th[1], th[2], pch = 19, cex = 1.0, col = "BLUE")
th <-sth2$theta
points (th[1], th[2], pch = 19, cex = 1.0, col = "BLUE")
th <- -th
points (th[1], th[2], pch = 19, cex = 1.0, col = "BLUE")
th <-sth3$theta
points (th[1], th[2], pch = 19, cex = 1.0, col = "BLUE")
th <- -th
points (th[1], th[2], pch = 19, cex = 1.0, col = "BLUE")
th <-sth4$theta
points (th[1], th[2], pch = 19, cex = 1.0, col = "RED")
th <- -th
points (th[1], th[2], pch = 19, cex = 1.0, col = "RED")
th <-sth5$theta
points (th[1], th[2], pch = 19, cex = 1.0, col = "RED")
th <- -th
points (th[1], th[2], pch = 19, cex = 1.0, col = "RED")
```
<center>
`r figure_nums("global_contour")`
</center>
<hr>

## Stationary Points

### First Minimum

We zoom in on the first local minimum at (`r sth1$theta`). Its stress is `r sth1$stress` and the corresponding configuration is in figure `r figure_nums("configuration_first_minimum", display = "n")`.
<hr>
```{r configuration_first_minimum, fig.align= "center", echo = FALSE, cache = FALSE}
par(pty="s")
plot(xso1, type = "n", xlab = "dim 1", ylab = "dim 2")
text (xso1, as.character(1:4),col = "RED")
```
<center>
`r figure_nums("configuration_first_minimum")`
</center>
<hr>
Note that this local minimum corresponds with the equilateral triangle with center, which is a saddle point in configuration space (@trosset_mathar_97).
The eigenvalues of $B(\theta)$ are (`r zapsmall(eigen(sth1$b)$values)`) and those of the Hessian $I-H(\theta)$ are
(`r zapsmall(eigen(sth1$h)$values)`). The area of the contour plot around the stationary value is in figure `r figure_nums("contour_first_minimum", display = "n")`.

```{r values_first_minimum, echo = FALSE, cache = TRUE}
aa <- bb <- seq (.7, 1.2, length = 100)
z <- matrix (0, 100, 100)
for (i in 1:100) for (j in 1:100)
  z[i, j]<- stress (aa[i], bb[j], x, y, delta)
```
<hr>
```{r contour_first_minimum, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
par(pty="s")
contour(aa, bb, z, levels = seq(0.065,.08,length=100))
th <- sth1$theta
points (th[1], th[2], pch = 19, cex = 1.5, col = "BLUE")
```
<center>
`r figure_nums("contour_first_minimum")`
</center>
<hr>

### Second Minimum

The second local minimum (which is the global minimum) at (`r zapsmall(sth2$theta)`) has stress `r sth2$stress` and the corresponding configuration is in figure `r figure_nums("configuration_second_minimum", display = "n")`.
<hr>
```{r configuration_second_minimum, fig.align= "center", echo = FALSE, cache = FALSE}
par(pty="s")
plot(xso2, type = "n", xlab = "dim 1", ylab = "dim 2")
text (xso2, as.character(1:4),col = "RED")
```
<center>
`r figure_nums("configuration_second_minimum")`
</center>
<hr>
The eigenvalues of $B(\theta)$ are (`r zapsmall(eigen(sth2$b)$values)`) and those of the Hessian $I-H(\theta)$ are
(`r zapsmall(eigen(sth2$h)$values)`). The area of the contour plot around the stationary value is in figure `r figure_nums("contour_second_minimum", display = "n")`.

```{r values_second_minimum, echo = FALSE, cache = TRUE}
aa <- seq (1, 2, length = 100)
bb <- seq (-.5,.5, length=100)
z <- matrix (0, 100, 100)
for (i in 1:100) for (j in 1:100)
  z[i, j]<- stress (aa[i], bb[j], x, y, delta)
```
<hr>
```{r contour_second_minimum, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
par(pty="s")
contour(aa, bb, z, levels = seq(0.02,.10,length=100))
th <- sth2$theta
points (th[1], th[2], pch = 19, cex = 1.5, col = "BLUE")
```
<center>
`r figure_nums("contour_second_minimum")`
</center>
<hr>

### Third Minimum

The third local minimum at (`r sth3$theta`) has stress `r sth3$stress` and the corresponding configuration is in figure `r figure_nums("configuration_third_minimum", display = "n")`.
<hr>
```{r configuration_third_minimum, fig.align= "center", echo = FALSE, cache = FALSE}
par(pty="s")
plot(xso3, type = "n", xlab = "dim 1", ylab = "dim 2")
text (xso3, as.character(1:4),col = "RED")
```
<center>
`r figure_nums("configuration_third_minimum")`
</center>
<hr>
The eigenvalues of $B(\theta)$ are (`r zapsmall(eigen(sth3$b)$values)`) and those of the Hessian $I-H(\theta)$ are
(`r zapsmall(eigen(sth3$h)$values)`). The area of the contour plot around the stationary value is in figure `r figure_nums("contour_third_minimum", display = "n")`.


```{r values_third_minimum, echo = FALSE, cache = TRUE}
aa <- seq (-.5, .5, length = 100)
bb <- seq (1, 2, length = 100)
z <- matrix (0, 100, 100)
for (i in 1:100) for (j in 1:100)
  z[i, j]<- stress (aa[i], bb[j], x, y, delta)
```
<hr>
```{r contour_third_minimum, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
par(pty="s")
contour(aa, bb, z, levels = seq(.11,.20,length=100))
th <- sth3$theta
points (th[1], th[2], pch = 19, cex = 1.5, col = "BLUE")
```
<center>
`r figure_nums("contour_third_minimum")`
</center>
<hr>

### First Saddle Point

The saddle point at (`r sth4$theta`) has stress `r sth4$stress` and the corresponding configuration is in figure `r figure_nums("configuration_first_saddlepoint", display = "n")`.
<hr>
```{r configuration_first_saddlepoint, fig.align= "center", echo = FALSE, cache = FALSE}
par(pty="s")
plot(xso4, type = "n", xlab = "dim 1", ylab = "dim 2")
text (xso4, as.character(1:4),col = "RED")
```
<center>
`r figure_nums("configuration_first_saddlepoint")`
</center>
<hr>
The eigenvalues of $B(\theta)$ are (`r zapsmall(eigen(sth4$b)$values)`) and those of the Hessian $I-H(\theta)$ are
(`r zapsmall(eigen(sth4$h)$values)`). The area of the contour plot around the stationary value is in figure `r figure_nums("contour_first_saddlepoint", display = "n")`.

```{r values_first_saddlepoint, echo = FALSE, cache = TRUE}
aa <- seq (.30, .34, length = 100)
bb <- seq (1.25, 1.30, length = 100)
z <- matrix (0, 100, 100)
for (i in 1:100) for (j in 1:100)
  z[i, j]<- stress (aa[i], bb[j], x, y, delta)
```
<hr>
```{r contour_first_saddlepoint, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
par(pty="s")
contour(aa, bb, z, levels = seq (.112, .113, length=100))
th <- sth4$theta
points (th[1], th[2], pch = 19, cex = 1.5, col = "RED")
```
<center>
`r figure_nums("contour_first_saddlepoint")`
</center>
<hr>

### Second Saddle Point

The saddle point at (`r sth5$theta`) has stress `r sth5$stress` and the corresponding configuration is in figure `r figure_nums("configuration_second_saddlepoint", display = "n")`.
<hr>
```{r configuration_second_saddlepoint, fig.align= "center", echo = FALSE, cache = FALSE}
par(pty="s")
plot(xso5, type = "n", xlab = "dim 1", ylab = "dim 2")
text (xso5, as.character(1:4),col = "RED")
```
<center>
`r figure_nums("configuration_second_saddlepoint")`
</center>
<hr>
The eigenvalues of $B(\theta)$ are (`r zapsmall(eigen(sth5$b)$values)`) and those of the Hessian $I-H(\theta)$ are
(`r zapsmall(eigen(sth5$h)$values)`). The area of the contour plot around the stationary value is in figure `r figure_nums("contour_second_saddlepoint", display = "n")`.

```{r values_second_saddlepoint, echo = FALSE, cache = TRUE}
aa <- seq (1.11, 1.14, length = 100)
bb <- seq (.76, .79, length = 100)
z <- matrix (0, 100, 100)
for (i in 1:100) for (j in 1:100)
  z[i, j]<- stress (aa[i], bb[j], x, y, delta)
```
<hr>
```{r contour_second_saddlepoint, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
par(pty="s")
contour(aa, bb, z, levels = seq (.0672, .0678, length=100))
th <- sth5$theta
points (th[1], th[2], pch = 19, cex = 1.5, col = "RED")
```
<center>
`r figure_nums("contour_second_saddlepoint")`
</center>
<hr>

## Regions of Attraction

### Smacof

We use the `smacof()` function from the code in the appendix with 100 different starting points of $\theta$, equally spaced on the circle. Figure `r figure_nums("histogram_smacof", display = "n")` is a histogram of the number of smacof iterations to convergence within $1e-15$. In all cases `smcof` converges to a local minimum in coefficient space, never to a saddle point.  Figure `r figure_nums("path_smacof", display = "n")` shows which local minima are reached from the different starting points.  This shows, more or less contrary to what @trosset_mathar_97 suggest, that non-global minima can indeed be points of attraction for `smacof` iterations.

```{r one_hundred_smacof, echo = FALSE, cache = TRUE}
xx <- seq (-2*pi, 2*pi, length = 100)
aa <- sin (xx)
bb <- cos (xx)
zs <- as.list(1:100)
ss <- ts <- gs <- rep (0, 100)
for (i in 1:100) {
  zs[[i]] <- smacof(aa[i], bb[i], x, y, delta, eps = 1e-15, verbose = FALSE)
  ss[i] <- zs[[i]]$stress
  gs[i] <- max(zs[[i]]$g)
  ts[i] <- min(eigen (zs[[i]]$h)$values)
}
```
<hr>
```{r histogram_smacof, fig.align= "center", echo = FALSE, cache = FALSE}
iterations <- sapply(zs, function (z) z$itel)
hist(iterations)
```
<center>
`r figure_nums("histogram_smacof")`
</center>
<hr>
<hr>
```{r path_smacof, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
par(pty="s")
plot (0, xlim = c(-2,2), ylim = c(-2,2), type = "n")
lines (aa, bb, col = "RED")
for (i in 1:100) {
  points (zs[[i]]$theta[1], zs[[i]]$theta[2], pch = 19, cex = 1.5, col = "BLUE")
  lines (matrix(c(aa[i], bb[i], zs[[i]]$theta), 2, 2, byrow = TRUE))
}
```
<center>
`r figure_nums("path_smacof")`
</center>
<hr>

### Newton

```{r one_hundred_newton, echo = FALSE, cache = TRUE}
xx <- seq (-2*pi, 2*pi, length = 100)
aa <- sin (xx)
bb <- cos (xx)
zn <- as.list(1:100)
sn <- tn <- gn <- rep (0, 100)
for (i in 1:100) {
  zn[[i]] <- newton(aa[i], bb[i], x, y, delta, eps = 1e-15, verbose = FALSE)
  sn[i] <- zn[[i]]$stress
  gn[i] <- max(zn[[i]]$g)
  tn[i] <- min(eigen (zn[[i]]$h)$values)
}
```
We repeat the same exercise with Newton's method, which converges from all 100 starting points. In higher dimensions we may not be so lucky. The histogram of
iteration counts is in figure `r figure_nums("histogram_newton", display = "n")`. It shows in this example that `smacof` needs about 10 times the number of iterations that Newton needs. Because `smacof` iterations are much less expensve than Newton ones, this does not really say much about computing times. If we look at figure `r figure_nums("path_newton", display = "n")` we see the problem with non-safeguarded Newton. Although we have fast convergence from all 100 starting points, Newton converges to a saddle point in `r length(which(tn < 0))` cases.

<hr>
```{r histogram_newton, fig.align= "center", echo = FALSE, cache = FALSE}
iterations <- sapply(zn, function (z) z$itel)
hist(iterations)
```
<center>
`r figure_nums("histogram_newton")`
</center>
<hr>
<hr>
```{r path_newton, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
par(pty="s")
plot (0, xlim = c(-2,2), ylim = c(-2,2), type = "n")
lines (aa, bb, col = "RED")
for (i in 1:100) {
  points (zn[[i]]$theta[1], zn[[i]]$theta[2], pch = 19, cex = 1.5, col = "BLUE")
  lines (matrix(c(aa[i], bb[i], zn[[i]]$theta), 2, 2, byrow = TRUE))
}
```
<center>
`r figure_nums("path_newton")`
</center>
<hr>

## Another Look

Remember that $\rho(\theta)=\theta'B(\theta)\theta$. Thus $\sigma(\lambda\theta)=1-\lambda\rho(\theta)+\frac12\lambda^2\theta'\theta$, and
$$
\min_\lambda\sigma(\lambda\theta)=1-\frac12\frac{\rho^2(\theta)}{\theta'\theta}.
$$
Thus we can minimize $\sigma$ over $\theta$ by maximizing $\rho$ over the unit circle $\mathcal{S}:=\{\theta\mid\theta'\theta=1\}$. This is a nice formulation, because 
$\rho$ is norm, i.e. a homogeneous convex function of $\theta$. Consequently we have transformed the problem from unconstrained minimization of the DC 
function (i.e. difference of convex functions) stress to that of maximization of a ratio of norms. In turn this is equivalent to maximization of the convex function $\rho$ over the unit circle, or, again equivalently, over the unit ball, a compact convex set.  This transform was first used in MDS by @deleeuw_C_77, partly because it made the theory developed by @robert_67 available.

The levels sets $\{\theta\mid\rho(\theta)=\kappa\}$ are the $\rho$-circles defined by the norm $\rho$. The corresponding $\rho$-balls $\{\theta\mid\rho(\theta)\leq\kappa\}$ are closed and nested convex sets containing the origin. Thus we want to find the largest $\rho$-circle that
still intersects $\mathcal{S}$. The similarity with the geometry of eigenvalue problems is obvious.

```{r ropt, echo = FALSE}
ph<-sth2$theta / sqrt (sum (sth2$theta ^ 2))
ropt <- rho (ph[1], ph[2], x, y, delta)
```
In our example we know that the global optimum of stress is at (`r zapsmall(sth2$theta)`), and if we project that point on the circle it becomes (`r zapsmall(ph)`). The corresponding optimal $\rho$ is `r ropt`. Figure `r figure_nums("rho_contour", display = "n")` gives the contourplot for $\rho$, with the outer $\rho$-circle corresponding with the optimal value. The fact that the optimal value contour is disjoint from the interior of $\mathcal{S}$ is necessary and sufficient for global optimality (@dur_horst_locatelli_98). Notice the sharp corners in the contour plot, showing the non-diffentiability of $\rho$ at the points
where $d_{12}(\theta)=0$. We could also look for the minimum of $\rho$ on the unit circle, which means finding the largest $\rho$-circle that touches
$\mathcal{S}$ on the inside. Inspecting figure `r figure_nums("rho_contour", display = "n")` shows that this will be a point where $\rho$ is not
differentiable, i.e. a point with $d_{12}(\theta)=0$. This minimum $\rho$ problem does not make much sense in the context of multidimensional scaling,
however, and it not related directly to the minimization of stress.

```{r rho_values, echo = FALSE, cache = TRUE}
aa <- bb <- seq (-1.2, 1.2, length = 100)
z <- matrix (0, 100, 100)
for (i in 1:100) for (j in 1:100)
  z[i, j]<- rho (aa[i], bb[j], x, y, delta)
```
<hr>
```{r rho_contour, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
par(pty="s")
contour(aa, bb, z, levels = c(seq(0,1.3,length = 14), ropt), lwd = 2, col = "BLUE")
av <- seq (0,  2 * pi, length = 100)
bv <- sin (av)
cv <- cos (av)
lines(bv,cv,col="RED",lwd=3)
```
<center>
`r figure_nums("rho_contour")`
</center>
<hr>

## A Final Look

Now that we know that the MDS problem is equivalent to maximizing $\rho$ on the unit circle, we can use nonlinear coordinates $(\theta_1,\theta_2)=(\sin\xi,\cos\xi)$ to reduce the problem to a one-dimensional unconstrained one in, say, ``circle space''. Thus, with the same abuse of notation as for stress, $\rho(\xi):=\rho(\sin\xi,\cos\xi)$, and we have to maximize $\rho$ over $0\leq\xi\leq\pi$. 

In figure `r figure_nums("rho_nonlinear_plot", display = "n")` we have plotted $\rho$ as a function of $\eta$. There are blue vertical lines at the three local minima in coefficient space,
red vertical lines at the stationary points, and a green vertical line where $d_{12}(\xi)=0$. Note that in circle space stress has both multiple local minima and multiple local maxima.
<hr>
```{r rho_nonlinear_values, echo = FALSE, cache = TRUE}
par(pty="s")
av <- seq (0,  pi, length = 10000)
bv <- rep(0, 10000)
sav <- sin (av)
cav <- cos (av)
for (i in 1:10000)
  bv[i] <- rho (sav[i], cav[i], x, y, delta)
```
```{r rho_nonlinear_plot, fig.align= "center", fig.width = 10, fig.height = 10, echo = FALSE, cache = FALSE}
plot (av, bv, type = "l", col = "RED", lwd = 2, xlab = "xi", ylab = "rho")
th1 <- sth1$theta
th1 <- th1 / sqrt (sum (th1 ^ 2))
xi1 <- asin (th1[1])
abline (v = xi1, col = "BLUE")
th2 <- sth2$theta
th2 <- th2 / sqrt (sum (th2 ^ 2))
xi2 <- asin (th2[1])
abline (v = xi2, col = "BLUE")
th3 <- sth3$theta
th3 <- th3 / sqrt (sum (th3 ^ 2))
xi3 <- asin (th3[1])
abline (v = xi3, col = "BLUE")
th4 <- sth4$theta
th4 <- th4 / sqrt (sum (th4 ^ 2))
xi4 <- asin (th4[1])
abline (v = xi4, col = "RED")
th5 <- sth5$theta
th5 <- th5 / sqrt (sum (th5 ^ 2))
xi5 <- asin (th5[1])
abline (v = xi5, col = "RED")
th0 <- th0 / sqrt (sum (th0 ^ 2))
xi0 <- asin (th0[1])
abline (v = pi+xi0, col = "GREEN")
```
<center>
`r figure_nums("rho_nonlinear_plot")`
</center>
<hr>


```{r second_derivatives, echo = FALSE}
th <- sth1$theta
th <- th / sqrt (sum (th ^ 2))
bh <- bmat (th[1], th[2], x, y, delta)
eh <- max (eigen (bh$h)$values)
rh <- rho (th[1], th[2], x, y, delta)
hes1 <- eh - rh
th <- sth2$theta
th <- th / sqrt (sum (th ^ 2))
bh <- bmat (th[1], th[2], x, y, delta)
eh <- max (eigen (bh$h)$values)
rh <- rho (th[1], th[2], x, y, delta)
hes2 <- eh - rh
th <- sth3$theta
th <- th / sqrt (sum (th ^ 2))
bh <- bmat (th[1], th[2], x, y, delta)
eh <- max (eigen (bh$h)$values)
rh <- rho (th[1], th[2], x, y, delta)
hes3 <- eh - rh
th <- sth4$theta
th <- th / sqrt (sum (th ^ 2))
bh <- bmat (th[1], th[2], x, y, delta)
eh <- max (eigen (bh$h)$values)
rh <- rho (th[1], th[2], x, y, delta)
hes4 <- eh - rh
th <- sth5$theta
th <- th / sqrt (sum (th ^ 2))
bh <- bmat (th[1], th[2], x, y, delta)
eh <- max (eigen (bh$h)$values)
rh <- rho (th[1], th[2], x, y, delta)
hes5 <- eh - rh
```
From lemma `r lemma_nums("nonlinear", display = "n")` we see that the second derivative $\mathcal{D}^2\rho(\xi)$ is equal to $\mathbf{tr}\ H(\xi)-\rho(\xi)$.
For the three local minima in coordinate space we find second derivatives `r c(hes1, hes2, hes3)` in circle space, i.e. they are properly converted to local maxima. The two stationary points in coordinate space have second derivatives `r c(hes4, hes5)`, and are turned into local minima.

For more general cases, with a basis of $n$ configurations, we know from @lyusternik-schnirelmann_34 that a continuously differentiable even function on the unit sphere in $\mathbb{R}^n$ has at least $n$ distinct pairs of stationary points.

# Second Example

$theta$ and $B(\theta)\theta$

# Three Points

$theta$ and $B(\theta)\theta$ and $(I - H(\theta))^{-1}B(\theta)\theta$

# Discussion

Although our results are based on a single small example, there are some general conclusions we can draw.

Stess has no local maxima, except one at the origin. It has saddle points and non-global minima. If we reparametrize configuration space by using linear combinations of a fixed number of configurations we can ``upgrade'' some of the stationary point to local minima. If we remove homogeneity from the problem by working on the unit ball that can upgrade even more stationary points.

In comparing `smacof` with Newton we have found, not surprisingly, that Newton uses fewer iterations but often converges to saddle points. 

```{r mathar_trosset, echo = FALSE, cache = TRUE}
set.seed(12345)
delta <- 1 - diag (4)
delta <- delta * sqrt (2 / sum (delta ^ 2))
a<-3+sqrt(3)
x<-matrix (c(0, 2*a, a, a, 0, 0, a*sqrt(3), a*sqrt(3)/3), 4, 2)
x <- apply (x, 2, function (x) x - mean (x))
dx<- as.matrix(dist(x))
lb <- sum (delta * dx) / sum (dx ^ 2)
x <- lb * x
z <- matrix (c(0, -2, sqrt(3), -2-sqrt(3)/3, 0, 0, sqrt(3),2 +sqrt(3)), 4, 2)
z <- apply (z, 2, function (x) x - mean (x))

bmat2 <- function (x) {
  dx <- as.matrix (dist (x))
  b <- - delta / (dx + diag (4))
  diag (b) <- - rowSums (b)
  return (b)
}

stress2 <- function (x) {
  dx <- as.matrix (dist (x))
  return (sum ((delta - dx) ^ 2) / 2)
}

smacof2 <- function (xold, itmax = 10000, eps = 1e-15) {
  fold <- stress2 (xold)
  itel <- 1
  path <- numeric(0)
  repeat {
    b <- bmat2 (xold)
    xnew <- b %*% xold / 4
    fnew <- stress2 (xnew)
    path <- c(path, fnew)
    if (((fold - fnew) < eps) || (itel == itmax)) break
    fold <- fnew
    xold <- xnew
    itel <- itel + 1
  }
  return (list (x = xnew, itel = itel, stress = fnew, path = path))
}

h <- smacof2 (x + .001 * matrix (rnorm (8), 4, 2))
s1 <- h$path[1]
sn <- h$path[h$itel]
ss <- stress2(x)
```
The finding that saddle points in configuration space can correspond with local minima in coefficient space has an interesting implication for the `smacof` algorithm. We know that the set of starting points from which `smacof` converges to a saddle point has measure zero, in other words unless you start in a saddle point, you will almost certainly converge to a local minimum (@lee_simchowitz_jordan_recht_16). 

To illustrate this we repeat a calculation done first in @deleeuw_A_88b. Suppose we start `smacof` iterations with the 
$Y+.001*E$, where $E$ are random standard normals, and $Y$ is the triangle with center (which has loss function value `r ss`). `smacof` starts with a loss function value for the perturbed $Y$ of `r s1`. It does not drop below 0.066 until iteration `r which(h$path < .066)[1]`. But then it rather quickly converges in iteration `r h$itel` to `r sn`, the loss function value of the global minimum, four points in the corners of a square. On the other hand, if we minimize $\sigma(\gamma)$  over $\gamma$ we have a non-zero probability of converging to the local minimum in coefficient space at $(0,1)$, i.e. to $Y$.

This indicates, perhaps, that `smacof` must be used with a somewhat higher precision than the default, and that testing for second derivative information is always a good idea, no matter what space we are working in.

Minimizing stress over a plane spanned by two configurations may seem somewhat artificial and limited. But think of the situation in which we use configurations $X$ and $Y=\mathcal{D}\sigma(X)$. Or, equivalently, $X$ and $B(X)X$. In that case minimizing over the plane means computing the optimal step size of a gradient step or the optimum over-relaxation of `smacof` iterations, a problem first addressed perhaps in @deleeuw_heiser_C_80. Or the case in which $Y$ is the Newton step, and optimizing over the plane is a stabilized version of Newton's method.

# Appendix: Two Lemmas

Here we present two lemmas that describe the change of coordinates from configuration space to coefficient space and then to circle space. The proofs, which are just simple computations, are omitted.
<hr>
**`r lemma_nums("linear", display = "f")`** Suppose $X$ and Y are $n\times m$ matrices and $f$ is a twice-differentiable function on $\mathbb{R}^{n\times m}$. Define $g(\alpha,\beta):=f(\alpha X+\beta Y)$. Then
$$
\mathcal{D}g(\alpha,\beta)=\begin{bmatrix}\mathbf{tr}\ X'\mathcal{D}f(\alpha X+\beta Y)\\
\mathbf{tr}\ Y'\mathcal{D}f(\alpha X+\beta Y)\end{bmatrix},
$$
and
$$
\mathcal{D}^2g(\alpha,\beta)=
\begin{bmatrix}
\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^n\sum_{\ell=1}^m x_{ij}x_{k\ell}\frac{\partial f^2}{\partial z_{ij}\partial z_{k\ell}}(\alpha X+\beta Y)&
\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^n\sum_{\ell=1}^m x_{ij}y_{k\ell}\frac{\partial f^2}{\partial z_{ij}\partial z_{k\ell}}(\alpha X+\beta Y)\\
\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^n\sum_{\ell=1}^m y_{ij}x_{k\ell}\frac{\partial f^2}{\partial z_{ij}\partial z_{k\ell}}(\alpha X+\beta Y)&
\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^n\sum_{\ell=1}^m y_{ij}y_{k\ell}\frac{\partial f^2}{\partial z_{ij}\partial z_{k\ell}}(\alpha X+\beta Y)
\end{bmatrix}.
$$
<hr>
It is clear how this result generalizes to linear combinations of more than two matrices.
<hr>
**`r lemma_nums("nonlinear", display = "f")`** If $f$ is a twice-differentiable function of two variables and $g(x)=f(sin(x),cos(x))$ then
$$
\mathcal{D}g(x)=y'\mathcal{D}f(z),
$$ 
with $z:=(sin(x),cos(x))$ and $y:=(cos(x),-sin(x))$, and
$$
\mathcal{D}^2g(x)=y'\mathcal{D}^2f(z)y-z'\mathcal{D}f(z).
$$
<hr>
More generally, if a differentiable function $f$ on the unit sphere has a stationary point at $\theta$ then $\theta'\theta=1$ and there is a multiplier $\lambda$ such that $\mathcal{D}f(\theta)=\lambda\theta$. If $f$ is homogeneous of degree one then $\theta'\mathcal{D}f(\theta)=f(\theta)$ and thus at a stationary point $\lambda=f(\theta)$. If the function is twice differentiable and the stationary point is a local maximum then in addition $\nu'\mathcal{D}^2f(\theta)\nu\leq\lambda$ for all $\nu'\nu=1$ and $\nu'\theta=0$. For a norm, i.e. a homogeneous convex $f$, this says equivalently that the largest eigenvalue of $\mathcal{D}^2f(\theta)$ is less than or equal to $f(\theta)$. Note that the second order necessary conditions for a local maximum become sufficient if the inequality is strict.


# Appendix: Code

```{r display_code, eval = FALSE}
bmat <- function (a, b, x, y, delta) {
  bm <- matrix (0, 2, 2)
  hm <- matrix (0, 2, 2)
  z <- c(a, b)
  for (i in 1:4) {
    for (j in 1:4) {
      if (i == j) next
      uij <- uu (i, j, x, y)
      uz <- drop (uij %*% z)
      dij <- sqrt (sum (uij * outer (z, z)))
      bm <- bm + (delta[i,j] / dij) * uij
      hm <- hm + (delta[i,j] / dij) * (uij - outer (uz, uz) / sum (z * uz))
    }
  }
  return (list (b = bm, h = hm))
}

stress <- function (a, b, x, y, delta) {
  z <- c (a, b)
  bm <- bmat (a, b, x, y, delta)$b
  return (1 + sum(z ^ 2) / 2 - sum (z * bm %*% z))
}

rho <- function (a, b, x, y, delta) {
  z <- c (a, b)
  bm <- bmat (a, b, x, y, delta)$b
  return (sum (z * bm %*% z))
}

vv <- function (i, j, x, y) {
  a <- matrix (0, 2, 2)
  a[1, 1] <- sum ((x[i, ]- x[j,]) ^ 2)
  a[2, 2] <- sum ((y[i, ]- y[j,]) ^ 2)
  a[1, 2] <- a[2, 1] <- sum ((x[i, ]- x[j,]) * (y[i, ]- y[j, ]))
  return (a)
}

uu <- function (i, j, x, y) {
  n <- nrow (x)
  asum <- 2 * n * matrix (c (sum(x ^ 2), sum (x * y), sum (x * y), sum (y ^ 2)), 2, 2)
  csum <- solve (chol (asum))
  return (t(csum) %*% vv (i, j, x, y) %*% csum)
}

smacof <- function (a, b, x, y, delta, eps = 1e-10, itmax = 1000, verbose = TRUE) {
  zold <- c(a,b)
  bold <- bmat (a, b, x, y, delta)$b
  fold <- 1 + sum(zold ^ 2) / 2 - sum (zold * bold %*% zold)
  itel <- 1
  repeat {
    znew <- drop (bold %*% zold)
    bhmt <- bmat (znew[1], znew[2], x, y, delta)
    bnew <- bhmt$b
    fnew <- 1 + sum(znew ^ 2) / 2 - sum (znew * bnew %*% znew)
    if (verbose) {
      cat (
        formatC (itel, width = 4, format = "d"),
        formatC (
          fold,
          digits = 10,
          width = 13,
          format = "f"
        ),
        formatC (
          fnew,
          digits = 10,
          width = 13,
          format = "f"
        ),
        "\n"
      )
    }
    if ((itel == itmax) || (fold - fnew) < eps)
      break ()
    itel <- itel + 1
    fold <- fnew
    zold <- znew
    bold <- bnew
  }
  return (list (stress = fnew, theta = znew, itel= itel, b = bnew, g = znew - bnew %*% znew, h = diag(2) - bhmt$h))
}


newton <- function (a, b, x, y, delta, eps = 1e-10, itmax = 1000, verbose = TRUE) {
  zold <- c(a,b)
  bhmt <- bmat (a, b, x, y, delta)
  bold <- bhmt$b
  hold <- diag(2) - bhmt$h
  fold <- 1 + sum(zold ^ 2) / 2 - sum (zold * bold %*% zold)
  itel <- 1
  repeat {
    znew <- drop (solve (hold, bold %*% zold))
    bhmt <- bmat (znew[1], znew[2], x, y, delta)
    bnew <- bhmt$b
    hnew <- diag(nrow(bnew)) - bhmt$h
    fnew <- 1 + sum(znew ^ 2) / 2 - sum (znew * bnew %*% znew)
    if (verbose) {
      cat (
        formatC (itel, width = 4, format = "d"),
        formatC (
          fold,
          digits = 10,
          width = 13,
          format = "f"
        ),
        formatC (
          fnew,
          digits = 10,
          width = 13,
          format = "f"
        ),
        "\n"
      )
    }
    if ((itel == itmax) || abs (fold - fnew) < eps)
      break ()
    itel <- itel + 1
    fold <- fnew
    zold <- znew
    bold <- bnew
    hold <- hnew
  }
  return (list (stress = fnew, theta = znew, itel = itel, b = bnew, g = znew - bnew %*% znew, h = hnew))
}

mprint <- function (x, d = 2, w = 5) {
  print (noquote (formatC (x, di = d, wi = w, fo = "f")))
}
```

# References